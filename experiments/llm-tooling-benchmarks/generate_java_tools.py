#!/usr/bin/env python3
"""
Generate LangChain4j tool methods in the Tools class from JSON definitions.

The script reads tools_limited.json (produced by generate_tools_json.py) to
discover which tool identifiers should be exposed, then looks up detailed
descriptions in tools.json. Each tool becomes a method that accepts a single
String argument and returns a stub payload containing the tool name, with the
LangChain4j @Tool annotation populated from the source description. Re-running
the script simply rewrites the generated file.
"""

from __future__ import annotations

import argparse
import json
import re
from pathlib import Path

DEFAULT_LIMITED_JSON = Path("tools_limited.json")
DEFAULT_ALL_TOOLS_JSON = Path("tools.json")
JAVA_FILE = Path("src/main/java/com/martinkoubek/llm_tooling_benchmarks/Tools.java")
PACKAGE_NAME = "com.martinkoubek.llm_tooling_benchmarks"
AUTOGEN_NOTICE = (
    "// Auto-generated by ToolsExperiment/generate_java_tools.py using tools_limited.json and tools.json. "
    "Do not edit manually.\n"
)


def snake_to_camel(name: str) -> str:
    """Convert snake_case strings to lowerCamelCase."""
    parts = re.split(r"[^a-zA-Z0-9]+", name)
    parts = [p for p in parts if p]
    if not parts:
        raise ValueError(f"Cannot derive method name from '{name}'")
    first, *rest = parts
    return first.lower() + "".join(segment.capitalize() for segment in rest)


def escape_java_string(value: str) -> str:
    """Escape characters that are unsafe in Java string literals."""
    normalized = (
        value.replace("“", '"')
        .replace("”", '"')
        .replace("’", "'")
        .replace("–", "-")
        .replace("—", "-")
    )
    return (
        normalized.replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("\n", "\\n")
        .replace("\r", "\\r")
    )


def load_limited_entries(limited_path: Path) -> list[dict[str, object]]:
    if not limited_path.exists():
        raise FileNotFoundError(f"Expected limited tools definition at {limited_path}")
    with limited_path.open(encoding="utf-8") as fh:
        data = json.load(fh)

    if isinstance(data, dict):
        tools_raw = data.get("tools")
        if tools_raw is None:
            raise ValueError(f"{limited_path} must include a 'tools' key containing the tool definitions.")
    else:
        tools_raw = data

    if not isinstance(tools_raw, list):
        raise ValueError(f"{limited_path} must contain a list of tool definitions.")

    entries: list[dict[str, object]] = []
    for entry in tools_raw:
        if not isinstance(entry, dict):
            raise ValueError("Each tool definition must be an object.")
        tool_names = entry.get("tools")
        if not isinstance(tool_names, list) or not tool_names:
            raise ValueError("Each entry must include a non-empty 'tools' array.")
        if not all(isinstance(name, str) and name for name in tool_names):
            raise ValueError("'tools' entries must be non-empty strings.")
        prompt = (entry.get("prompt") or "").strip()
        entries.append({"tools": tool_names, "prompt": prompt})
    return entries


def collect_tool_names(limited_entries: list[dict[str, object]]) -> list[str]:
    """Return the tool identifiers referenced in limited_entries, preserving order."""
    seen: set[str] = set()
    ordered: list[str] = []
    for entry in limited_entries:
        tool_names = entry["tools"]
        assert isinstance(tool_names, list)
        for name in tool_names:
            if name not in seen:
                seen.add(name)
                ordered.append(name)
    return ordered


def load_tool_catalog(catalog_path: Path) -> dict[str, dict[str, str]]:
    if not catalog_path.exists():
        raise FileNotFoundError(f"Expected master tools definition at {catalog_path}")
    with catalog_path.open(encoding="utf-8") as fh:
        data = json.load(fh)
    if not isinstance(data, list):
        raise ValueError(f"{catalog_path} must contain a list of tool definitions.")

    catalog: dict[str, dict[str, str]] = {}
    for entry in data:
        if not isinstance(entry, dict):
            raise ValueError("Each catalog tool definition must be an object.")
        name = entry.get("name")
        description = (entry.get("description") or "").strip()
        prompt = (entry.get("prompt") or "").strip()
        if not isinstance(name, str) or not name:
            raise ValueError("Each catalog entry must include a non-empty 'name'.")
        if not description:
            raise ValueError(f"Catalog entry '{name}' must include a 'description'.")
        catalog[name] = {"description": description, "prompt": prompt}
    return catalog


def build_method(name: str, description: str) -> str:
    method_name = snake_to_camel(name)
    escaped_description = escape_java_string(description.strip())
    escaped_name = escape_java_string(name)
    return (
        f'    @Tool("{escaped_description}")\n'
        f"    String {method_name}(@P(\"input\") String input) {{\n"
        f'        return "Done, details {escaped_name}";\n'
        f"    }}"
    )


def render_methods(tools: list[tuple[str, str]]) -> str:
    snippets = [build_method(name, description) for name, description in tools]
    if not snippets:
        return ""
    return "\n\n".join(snippets) + "\n"


def build_class_source(generated_block: str) -> str:
    imports = "\n".join(
        [
            "import dev.langchain4j.agent.tool.P;",
            "import dev.langchain4j.agent.tool.Tool;",
            "import java.util.List;",
        ]
    )
    sum_method = (
        "    @Tool(\"Sum a list of integers\")\n"
        "    int sum(@P(\"numbers\") List<Integer> numbers) {\n"
        "        return numbers.stream().mapToInt(Integer::intValue).sum();\n"
        "    }\n"
    )
    body_parts = [
        AUTOGEN_NOTICE,
        f"package {PACKAGE_NAME};\n\n",
        f"{imports}\n\n",
        "public class Tools {\n\n",
        f"{sum_method}\n",
    ]
    if generated_block:
        body_parts.append(generated_block)
    body_parts.append("}\n")
    return "".join(body_parts)


def write_tools_file(generated_block: str) -> None:
    source = build_class_source(generated_block)
    JAVA_FILE.parent.mkdir(parents=True, exist_ok=True)
    JAVA_FILE.write_text(source, encoding="utf-8")


def parse_args() -> tuple[Path, Path]:
    parser = argparse.ArgumentParser(
        description=(
            "Generate the Tools.java class from tools_limited.json and tools.json. "
            "Use --limited to point at the sampled tool set and --catalog for the full definitions."
        )
    )
    parser.add_argument(
        "--limited",
        type=Path,
        default=DEFAULT_LIMITED_JSON,
        help=f"Path to the limited tool set (default: {DEFAULT_LIMITED_JSON}).",
    )
    parser.add_argument(
        "--catalog",
        type=Path,
        default=DEFAULT_ALL_TOOLS_JSON,
        help=f"Path to the master tools catalog (default: {DEFAULT_ALL_TOOLS_JSON}).",
    )
    args = parser.parse_args()
    return args.limited, args.catalog


def main() -> None:
    limited_path, catalog_path = parse_args()
    limited_entries = load_limited_entries(limited_path)
    catalog = load_tool_catalog(catalog_path)
    tool_names = collect_tool_names(limited_entries)
    selected_tools: list[tuple[str, str]] = []
    missing: list[str] = []
    for name in tool_names:
        if name not in catalog:
            missing.append(name)
        else:
            selected_tools.append((name, catalog[name]["description"]))
    if missing:
        missing_display = ", ".join(sorted(missing))
        raise ValueError(f"Tools missing from catalog: {missing_display}")
    generated_methods = render_methods(selected_tools)
    write_tools_file(generated_methods)


if __name__ == "__main__":
    main()
